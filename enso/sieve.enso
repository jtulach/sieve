import Standard.Base.Meta
import Standard.Base.Runtime.Unsafe
import Standard.Base.Data.Time
from Standard.Base.Data.Boolean import True, False
from Standard.Base import IO

type Gen
    type Generator a:Int

    next : Gen
    next =
        Unsafe.set_atom_field self 0 self.a+1
        self.a

    n = self.a

natural : Gen
natural = Generator 1

type ComputedPrimes
    type Primes generator filter
    type NoPrimes generator

Primes.next = case self of
    NoPrimes g -> Primes g (here.filter g.next)
    Primes g f ->
        case f.acceptAndAdd g.next of
            False -> @Tail_Call self.next
            True ->
                self

NoPrimes.next = case self of
    NoPrimes g -> Primes g (here.filter g.next)

Primes.lastPrime = case self of
    Primes g _ -> g.n - 1

compute_nth_prime : Primes -> Int -> Any
compute_nth_prime p n = if n == 0 then p else
    pn = p.next
    @Tail_Call here.compute_nth_prime pn n-1

main =
    at = Time.now.to_epoch_milliseconds
    p = NoPrimes here.natural
    r = here.compute_nth_prime p 100000
    now = Time.now.to_epoch_milliseconds
    IO.println <| "Hundred thousand prime numbers in " + (now - at).to_text + " ms. Last one is " + r.lastPrime.to_text
    @Tail_Call here.main

foreign js filter number = """
    function Filter(number) {
        this.number = number;
        this.next = null;
        this.last = this;
    }
    Filter.prototype.acceptAndAdd = function(n) {
      var filter = this;
      var sqrt = Math.sqrt(n);
      for (;;) {
          if (n % filter.number === 0) {
              return false;
          }
          if (filter.number > sqrt) {
              break;
          }
          filter = filter.next;
      }
      var newFilter = new Filter(n);
      this.last.next = newFilter;
      this.last = newFilter;
      return true;
    };
    return new Filter(number);
