import Standard.Base.Meta
import Standard.Base.Runtime.Unsafe
import Standard.Base.Data.Time
from Standard.Base.Data.Boolean import True, False
from Standard.Base import IO

type Filter
    type Empty
    type Item n:Int next:Filter
    type Head first:Filter last:Filter

    acceptAndAdd : Int -> Boolean
    acceptAndAdd n =
        upto = n.sqrt

        iterate f = case f of
            Item p next -> if n % p == 0 then False else
                if p > upto then True else @Tail_Call iterate next
            Empty -> True

        appendN head last =
            newLast = Item n Empty
            Unsafe.set_atom_field last 1 newLast
            Unsafe.set_atom_field head 1 newLast
            head

        case self of
            Empty ->
                first = Item n Empty
                Head first first
            Head _ _ -> if iterate self.first then appendN self self.last else Empty

type Primes generator filter

Primes.next = case self of
    Primes g f ->
        case f.acceptAndAdd g.next of
            Empty -> @Tail_Call self.next
            head ->
                Unsafe.set_atom_field self 1 head
                self

Primes.lastPrime = case self of
    Primes g _ -> g.n - 1

compute_nth_prime : Primes -> Int -> Any
compute_nth_prime p n = if n == 0 then p else
    pn = p.next
    @Tail_Call here.compute_nth_prime pn n-1

main =
    at = Time.now.to_epoch_milliseconds
    p = Primes here.natural Empty
    r = here.compute_nth_prime p 100000
    now = Time.now.to_epoch_milliseconds
    IO.println <| "Hundred thousand prime numbers in " + (now - at).to_text + " ms. Last one is " + r.lastPrime.to_text
    @Tail_Call here.main


foreign js natural = """
    function Natural() {
        this.n = 2;
    }
    Natural.prototype.next = function() {
        return this.n++;
    }
    return new Natural();
